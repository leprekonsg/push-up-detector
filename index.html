<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STF AI(çˆ±) Exercise Counter - Push-ups, Sit-ups, Squats & Jumping Jacks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
            image-rendering: optimizeSpeed;
        }

        #video {
            display: none;
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.85);
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 240px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .exercise-type {
            font-size: 14px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .count {
            font-size: 56px;
            font-weight: 700;
            color: #00ff88;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
            font-variant-numeric: tabular-nums;
        }

        .stage {
            font-size: 20px;
            color: #888;
            margin-bottom: 20px;
            transition: color 0.3s ease;
        }

        .stage.down {
            color: #ff6b6b;
        }

        .stage.up {
            color: #00ff88;
        }

        .metrics {
            display: grid;
            gap: 15px;
            margin-top: 20px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .metric-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }

        .angle-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
            position: relative;
        }

        .angle-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #ffd93d 50%, #00ff88 100%);
            width: 0%;
            transition: width 0.1s ease;
        }

        .angle-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .angle-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
        }

        .form-indicator {
            margin-top: 15px;
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .form-indicator.good {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .form-indicator.warning {
            background: rgba(255, 215, 0, 0.1);
            color: #ffd700;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .form-indicator.error {
            background: rgba(255, 107, 107, 0.1);
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .exercise-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            background: rgba(10, 10, 10, 0.85);
            padding: 10px;
            border-radius: 15px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .exercise-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .exercise-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .exercise-btn.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: rgba(0, 255, 136, 0.4);
            color: #00ff88;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: rgba(0, 255, 136, 0.4);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 30px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 15px;
            max-width: 400px;
        }

        .performance-mode {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.85);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        .fps {
            color: #00ff88;
            font-weight: 600;
        }

        @media (max-width: 600px) {
            #stats {
                top: 10px;
                left: 10px;
                padding: 20px;
                min-width: 180px;
            }
            
            .count {
                font-size: 42px;
            }
            
            .exercise-selector {
                top: auto;
                bottom: 100px;
                right: 50%;
                transform: translateX(50%);
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .controls {
                bottom: 15px;
                gap: 10px;
            }
            
            button {
                padding: 12px 20px;
                font-size: 14px;
            }
            
            .performance-mode {
                display: none;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .count.pulse {
            animation: pulse 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
        
        <div id="loading">
            <div class="spinner"></div>
            <p>Loading MoveNet Lightning Model...</p>
            <p style="margin-top: 10px; color: #666; font-size: 14px;">Optimizing for performance...</p>
        </div>
        
        <div id="stats" style="display: none;">
            <div class="exercise-type" id="exerciseType">PUSH-UPS</div>
            <div class="count">0</div>
            <div class="stage">Ready to Start</div>
            
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label" id="angleLabel">Elbow Angle</div>
                    <div class="angle-bar">
                        <div class="angle-fill"></div>
                        <div class="angle-markers">
                            <div class="angle-marker" style="left: 25%"></div>
                            <div class="angle-marker" style="left: 75%"></div>
                        </div>
                    </div>
                </div>
                
                <div class="metric">
                    <div class="metric-label">Form Quality</div>
                    <div class="metric-value" id="formQuality">--</div>
                </div>
                
                <div class="metric">
                    <div class="metric-label">Rep Time</div>
                    <div class="metric-value" id="repTime">--</div>
                </div>
            </div>
            
            <div class="form-indicator" id="formIndicator" style="display: none;"></div>
        </div>
        
        <div class="exercise-selector" style="display: none;">
            <button class="exercise-btn active" onclick="exerciseCounter.setExercise('pushup')">Push-ups</button>
            <button class="exercise-btn" onclick="exerciseCounter.setExercise('situp')">Sit-ups</button>
            <button class="exercise-btn" onclick="exerciseCounter.setExercise('squat')">Squats</button>
            <button class="exercise-btn" onclick="exerciseCounter.setExercise('jumpingjack')">Jumping Jacks</button>
        </div>
        
        <div class="performance-mode" id="performanceMode" style="display: none;">
            <span class="fps">30 FPS</span> | <span id="latency">0ms</span>
        </div>
        
        <div class="controls" style="display: none;">
            <button onclick="exerciseCounter.reset()">Reset Count</button>
            <button onclick="exerciseCounter.toggleCamera()">Switch Camera</button>
            <button onclick="exerciseCounter.toggleSound()" id="soundBtn">Sound: ON</button>
            <button onclick="exerciseCounter.togglePerformanceMode()">Performance</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0/dist/pose-detection.min.js"></script>
    <script>
        class ExerciseCounter {
            constructor() {
                // Core components
                this.detector = null;
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.animationId = null;
                this.facingMode = 'user';
                
                // Exercise mode
                this.exerciseMode = 'pushup'; // 'pushup', 'situp', 'squat', 'jumpingjack'
                
                // Performance optimization
                this.frameSkip = 0;
                this.maxFrameSkip = 2;
                this.lastFrameTime = 0;
                this.fps = 30;
                this.performanceMode = false;
                
                // Exercise tracking
                this.exerciseCount = 0;
                this.stage = 'up';
                this.repStartTime = 0;
                this.lastRepTime = 0;
                
                // Smoothing buffers
                this.angleBuffer = [];
                this.bufferSize = 5;
                this.confidenceBuffer = [];
                this.movementBuffer = [];
                
                // Exercise-specific thresholds
                this.thresholds = {
                    pushup: {
                        angleDown: 90,
                        angleUp: 160,
                        minMovement: 20,
                        angleLabel: 'Elbow Angle'
                    },
                    situp: {
                        angleDown: 30,  // Torso close to ground
                        angleUp: 80,    // Torso raised
                        minMovement: 30,
                        angleLabel: 'Torso Angle'
                    },
                    squat: {
                        angleDown: 130,  // not so deep squat
                        angleUp: 160,   // Standing
                        minMovement: 30,
                        angleLabel: 'Knee Angle'
                    },
                    jumpingjack: {
                        feetTogetherRatio: 0.8, // feet width / shoulder width
                        feetApartRatio: 1.2,
                        armsDownThreshold: 0, // wrist y > hip y
                        armsUpThreshold: 1, // wrist y < shoulder y
                        angleLabel: 'Stance Width'
                    }
                };
                
                this.CONFIDENCE_THRESHOLD = 0.3;
                
                // Audio
                this.soundEnabled = true;
                this.audioContext = null;
                
                // Form analysis
                this.formQuality = 100;
                this.formErrors = [];
                this.previousFormError = null;
            }
            
            async init() {
                try {
                    this.video = document.getElementById('video');
                    this.canvas = document.getElementById('canvas');
                    this.ctx = this.canvas.getContext('2d', { 
                        alpha: false,
                        desynchronized: true
                    });
                    
                    this.initAudio();
                    
                    await tf.setBackend('webgl');
                    await tf.ready();
                    
                    const detectorConfig = {
                        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                        enableSmoothing: true,
                        minPoseScore: 0.25,
                        multiPoseMaxDimension: 256,
                        enableTracking: true,
                        trackerType: poseDetection.TrackerType.BoundingBox
                    };
                    
                    this.detector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        detectorConfig
                    );
                    
                    await this.setupCamera();
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('stats').style.display = 'block';
                    document.querySelector('.exercise-selector').style.display = 'flex';
                    document.querySelector('.controls').style.display = 'flex';
                    
                    this.speak("Ready to start pushups", true);
                    
                    this.checkPerformance();
                    this.detectPose();
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showError('Failed to initialize. Please ensure camera permissions are granted and refresh the page.');
                    this.speak("Error initializing. Please check permissions and refresh.", true);
                }
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API not supported.", e);
                    this.soundEnabled = false;
                    document.getElementById('soundBtn').textContent = 'Sound: OFF';
                    document.getElementById('soundBtn').classList.remove('active');
                }
            }

            speak(text, priority = false) {
                if (!this.soundEnabled || !text || !('speechSynthesis' in window)) {
                    return;
                }

                if (priority && window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                } else if (window.speechSynthesis.speaking && !priority) {
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US'; 
                utterance.rate = 1.1;     
                utterance.pitch = 1.0;    
                
                window.speechSynthesis.speak(utterance);
            }
            
            playSound(frequency, duration) {
                if (!this.soundEnabled || !this.audioContext || this.audioContext.state === 'suspended') {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().catch(e => console.warn("Could not resume audio context:", e));
                    }
                    return;
                }
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            async setupCamera() {
                const constraints = {
                    video: {
                        facingMode: this.facingMode,
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30, max: 30 }
                    }
                };
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = stream;
                    
                    return new Promise(resolve => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            this.canvas.width = this.video.videoWidth;
                            this.canvas.height = this.video.videoHeight;
                            resolve();
                        };
                    });
                } catch (err) {
                    console.error("Error accessing camera:", err);
                    this.showError(`Camera access denied or unavailable: ${err.message}. Please check permissions.`);
                    this.speak("Camera error. Please check permissions.", true);
                    throw err;
                }
            }
            
            checkPerformance() {
                let frameCount = 0;
                const startTime = performance.now();
                
                const measure = () => {
                    frameCount++;
                    if (frameCount < 30) {
                        requestAnimationFrame(measure);
                    } else {
                        const totalTime = performance.now() - startTime;
                        const avgFrameTime = totalTime / frameCount;
                        if (avgFrameTime > 66) {
                            this.maxFrameSkip = 3;
                            console.log('Low performance detected, increasing frame skipping.');
                        } else if (avgFrameTime > 40) {
                            this.maxFrameSkip = 2;
                            console.log('Moderate performance, setting frame skipping.');
                        } else {
                            this.maxFrameSkip = 1;
                        }
                    }
                };
                requestAnimationFrame(measure);
            }
            
            calculateAngle(a, b, c) {
                const radians = Math.atan2(c.y - b.y, c.x - b.x) - 
                               Math.atan2(a.y - b.y, a.x - b.x);
                let angle = Math.abs(radians * 180.0 / Math.PI);
                if (angle > 180.0) {
                    angle = 360 - angle;
                }
                return angle;
            }
            
            smoothValue(buffer, value, maxSize) {
                buffer.push(value);
                if (buffer.length > maxSize) {
                    buffer.shift();
                }
                return buffer.reduce((a, b) => a + b, 0) / buffer.length;
            }
            
            setExercise(type) {
                this.exerciseMode = type;
                this.reset();
                
                // Update UI
                document.querySelectorAll('.exercise-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                const typeText = {
                    'pushup': 'PUSHUPS',
                    'situp': 'SITUPS',
                    'squat': 'SQUATS',
                    'jumpingjack': 'JUMPING JACKS'
                };
                
                document.getElementById('exerciseType').textContent = typeText[type];
                document.getElementById('angleLabel').textContent = this.thresholds[type].angleLabel;
                
                this.speak(`Switched to ${typeText[type].toLowerCase()}`, true);
            }
            
            analyzeFormPushUp(keypoints) {
                const previousError = this.formErrors.length > 0 ? this.formErrors[0] : null;
                this.formErrors = [];
                let quality = 100;
                
                const LEFT_SHOULDER = 5, RIGHT_SHOULDER = 6;
                const LEFT_HIP = 11, RIGHT_HIP = 12;
                
                if (keypoints[LEFT_SHOULDER].score > this.CONFIDENCE_THRESHOLD && keypoints[RIGHT_SHOULDER].score > this.CONFIDENCE_THRESHOLD) {
                    const shoulderYDiff = Math.abs(keypoints[LEFT_SHOULDER].y - keypoints[RIGHT_SHOULDER].y);
                    if (shoulderYDiff > (this.canvas.height * 0.05)) {
                        this.formErrors.push('Keep shoulders level');
                        quality -= 20;
                    }
                }
                
                if (keypoints[LEFT_HIP].score > this.CONFIDENCE_THRESHOLD && keypoints[RIGHT_HIP].score > this.CONFIDENCE_THRESHOLD) {
                    const hipYDiff = Math.abs(keypoints[LEFT_HIP].y - keypoints[RIGHT_HIP].y);
                    if (hipYDiff > (this.canvas.height * 0.06)) {
                        this.formErrors.push('Keep hips aligned');
                        quality -= 20;
                    }
                }
                
                if (keypoints[LEFT_SHOULDER].score > this.CONFIDENCE_THRESHOLD && keypoints[RIGHT_SHOULDER].score > this.CONFIDENCE_THRESHOLD &&
                    keypoints[LEFT_HIP].score > this.CONFIDENCE_THRESHOLD && keypoints[RIGHT_HIP].score > this.CONFIDENCE_THRESHOLD) {
                    
                    const avgShoulderY = (keypoints[LEFT_SHOULDER].y + keypoints[RIGHT_SHOULDER].y) / 2;
                    const avgHipY = (keypoints[LEFT_HIP].y + keypoints[RIGHT_HIP].y) / 2;
                    
                    const bodyAngleDiff = Math.abs(avgShoulderY - avgHipY);
                    if (bodyAngleDiff > (this.canvas.height * 0.15)) {
                        this.formErrors.push('Keep body straight');
                        quality -= 30;
                    }
                }
                
                this.formQuality = Math.max(0, quality);
                
                if (this.formErrors.length > 0 && this.formErrors[0] !== this.previousFormError) {
                    this.speak(this.formErrors[0], false);
                    this.previousFormError = this.formErrors[0];
                } else if (this.formErrors.length === 0 && this.previousFormError !== null) {
                    this.previousFormError = null;
                }
                
                this.updateFormDisplay();
            }
            
            analyzeFormSitUp(keypoints) {
                const previousError = this.formErrors.length > 0 ? this.formErrors[0] : null;
                this.formErrors = [];
                let quality = 100;
                
                const LEFT_SHOULDER = 5, RIGHT_SHOULDER = 6;
                const LEFT_HIP = 11, RIGHT_HIP = 12;
                const LEFT_KNEE = 13, RIGHT_KNEE = 14;
                
                // Check if knees are bent (important for proper sit-up form)
                if (keypoints[LEFT_HIP].score > this.CONFIDENCE_THRESHOLD && 
                    keypoints[LEFT_KNEE].score > this.CONFIDENCE_THRESHOLD && 
                    keypoints[LEFT_SHOULDER].score > this.CONFIDENCE_THRESHOLD) {
                    
                    const kneeAngle = this.calculateAngle(
                        keypoints[LEFT_HIP], 
                        keypoints[LEFT_KNEE], 
                        {x: keypoints[LEFT_KNEE].x + 50, y: keypoints[LEFT_KNEE].y} // Approximate ankle position
                    );
                    
                    if (kneeAngle > 120) {
                        this.formErrors.push('Keep knees bent');
                        quality -= 30;
                    }
                }
                
                // Check if hands are behind head or across chest
                const LEFT_ELBOW = 7, RIGHT_ELBOW = 8;
                const LEFT_WRIST = 9, RIGHT_WRIST = 10;
                
                if (keypoints[LEFT_WRIST].score > this.CONFIDENCE_THRESHOLD && 
                    keypoints[RIGHT_WRIST].score > this.CONFIDENCE_THRESHOLD) {
                    
                    const avgWristY = (keypoints[LEFT_WRIST].y + keypoints[RIGHT_WRIST].y) / 2;
                    const avgShoulderY = (keypoints[LEFT_SHOULDER].y + keypoints[RIGHT_SHOULDER].y) / 2;
                    
                    if (avgWristY > avgShoulderY + (this.canvas.height * 0.1)) {
                        this.formErrors.push('Keep hands behind head or across chest');
                        quality -= 20;
                    }
                }
                
                this.formQuality = Math.max(0, quality);
                
                if (this.formErrors.length > 0 && this.formErrors[0] !== this.previousFormError) {
                    this.speak(this.formErrors[0], false);
                    this.previousFormError = this.formErrors[0];
                } else if (this.formErrors.length === 0 && this.previousFormError !== null) {
                    this.previousFormError = null;
                }
                
                this.updateFormDisplay();
            }
            
            analyzeFormSquat(keypoints) {
                const previousError = this.formErrors.length > 0 ? this.formErrors[0] : null;
                this.formErrors = [];
                let quality = 100;
                
                const LEFT_HIP = 11, RIGHT_HIP = 12;
                const LEFT_KNEE = 13, RIGHT_KNEE = 14;
                const LEFT_ANKLE = 15, RIGHT_ANKLE = 16;
                const LEFT_SHOULDER = 5, RIGHT_SHOULDER = 6;
                
                // Check knee alignment (knees shouldn't go too far past toes)
                if (keypoints[LEFT_KNEE].score > this.CONFIDENCE_THRESHOLD && 
                    keypoints[LEFT_ANKLE].score > this.CONFIDENCE_THRESHOLD) {
                    
                    const kneeX = keypoints[LEFT_KNEE].x;
                    const ankleX = keypoints[LEFT_ANKLE].x;
                    
                    if (Math.abs(kneeX - ankleX) > (this.canvas.width * 0.1)) {
                        this.formErrors.push('Keep knees aligned over feet');
                        quality -= 25;
                    }
                }
                
                // Check if back is straight (shoulders should be above hips)
                if (keypoints[LEFT_SHOULDER].score > this.CONFIDENCE_THRESHOLD && 
                    keypoints[LEFT_HIP].score > this.CONFIDENCE_THRESHOLD) {
                    
                    const shoulderX = keypoints[LEFT_SHOULDER].x;
                    const hipX = keypoints[LEFT_HIP].x;
                    
                    if (Math.abs(shoulderX - hipX) > (this.canvas.width * 0.08)) {
                        this.formErrors.push('Keep back straight');
                        quality -= 30;
                    }
                }
                
                // Check feet width (should be shoulder-width apart)
                if (keypoints[LEFT_ANKLE].score > this.CONFIDENCE_THRESHOLD && 
                    keypoints[RIGHT_ANKLE].score > this.CONFIDENCE_THRESHOLD &&
                    keypoints[LEFT_SHOULDER].score > this.CONFIDENCE_THRESHOLD && 
                    keypoints[RIGHT_SHOULDER].score > this.CONFIDENCE_THRESHOLD) {
                    
                    const feetWidth = Math.abs(keypoints[LEFT_ANKLE].x - keypoints[RIGHT_ANKLE].x);
                    const shoulderWidth = Math.abs(keypoints[LEFT_SHOULDER].x - keypoints[RIGHT_SHOULDER].x);
                    
                    if (feetWidth < shoulderWidth * 0.8 || feetWidth > shoulderWidth * 1.3) {
                        this.formErrors.push('Feet should be shoulder-width apart');
                        quality -= 20;
                    }
                }
                
                this.formQuality = Math.max(0, quality);
                
                if (this.formErrors.length > 0 && this.formErrors[0] !== this.previousFormError) {
                    this.speak(this.formErrors[0], false);
                    this.previousFormError = this.formErrors[0];
                } else if (this.formErrors.length === 0 && this.previousFormError !== null) {
                    this.previousFormError = null;
                }
                
                this.updateFormDisplay();
            }

            analyzeFormJumpingJack(keypoints) {
                const previousError = this.formErrors.length > 0 ? this.formErrors[0] : null;
                this.formErrors = [];
                let quality = 100;

                const LEFT_SHOULDER = 5, RIGHT_SHOULDER = 6;
                const LEFT_WRIST = 9, RIGHT_WRIST = 10;
                const LEFT_ANKLE = 15, RIGHT_ANKLE = 16;

                if (this.stage === 'up') {
                    const avgWristY = (keypoints[LEFT_WRIST].y + keypoints[RIGHT_WRIST].y) / 2;
                    const avgShoulderY = (keypoints[LEFT_SHOULDER].y + keypoints[RIGHT_SHOULDER].y) / 2;
                    if (avgWristY > avgShoulderY) {
                        this.formErrors.push('Raise arms higher');
                        quality -= 30;
                    }

                    const feetWidth = Math.abs(keypoints[LEFT_ANKLE].x - keypoints[RIGHT_ANKLE].x);
                    const shoulderWidth = Math.abs(keypoints[LEFT_SHOULDER].x - keypoints[RIGHT_SHOULDER].x);
                    if (feetWidth < shoulderWidth * this.thresholds.jumpingjack.feetApartRatio) {
                        this.formErrors.push('Spread feet wider');
                        quality -= 25;
                    }
                }

                this.formQuality = Math.max(0, quality);
                
                if (this.formErrors.length > 0 && this.formErrors[0] !== this.previousFormError) {
                    this.speak(this.formErrors[0], false);
                    this.previousFormError = this.formErrors[0];
                } else if (this.formErrors.length === 0 && this.previousFormError !== null) {
                    this.previousFormError = null;
                }
                
                this.updateFormDisplay();
            }
            
            updateFormDisplay() {
                const qualityEl = document.getElementById('formQuality');
                const indicatorEl = document.getElementById('formIndicator');
                
                qualityEl.textContent = `${this.formQuality}%`;
                
                if (this.formErrors.length > 0) {
                    indicatorEl.style.display = 'block';
                    indicatorEl.textContent = this.formErrors.join(', ');
                    
                    if (this.formQuality >= 80) {
                        indicatorEl.className = 'form-indicator good';
                    } else if (this.formQuality >= 50) {
                        indicatorEl.className = 'form-indicator warning';
                    } else {
                        indicatorEl.className = 'form-indicator error';
                    }
                } else {
                    indicatorEl.style.display = 'none';
                }
            }
            
            drawOptimized(keypoints) {
                let connections = [];
                
                switch(this.exerciseMode) {
                    case 'pushup':
                        connections = [
                            [5, 7], [7, 9],     // Left arm
                            [6, 8], [8, 10],    // Right arm
                            [5, 6],             // Shoulders
                            [11, 12],           // Hips
                            [5, 11], [6, 12]    // Torso
                        ];
                        break;
                    case 'situp':
                    case 'squat':
                    case 'jumpingjack':
                        connections = [
                            [5, 6],             // Shoulders
                            [5, 7], [7, 9],     // Left arm
                            [6, 8], [8, 10],    // Right arm
                            [11, 12],           // Hips
                            [5, 11], [6, 12],   // Torso
                            [11, 13], [12, 14], // Hip to knee
                            [13, 15], [14, 16]  // Knee to ankle
                        ];
                        break;
                }
                
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.fillStyle = '#00ff88';
                this.ctx.lineWidth = 3;
                
                this.ctx.beginPath();
                connections.forEach(([startIdx, endIdx]) => {
                    const kp1 = keypoints[startIdx];
                    const kp2 = keypoints[endIdx];
                    
                    if (kp1.score > this.CONFIDENCE_THRESHOLD && kp2.score > this.CONFIDENCE_THRESHOLD) {
                        this.ctx.moveTo(kp1.x, kp1.y);
                        this.ctx.lineTo(kp2.x, kp2.y);
                    }
                });
                this.ctx.stroke();
                
                const essentialKeypoints = this.exerciseMode === 'pushup' ? 
                    [5, 6, 7, 8, 9, 10, 11, 12] : 
                    [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
                    
                essentialKeypoints.forEach(idx => {
                    const kp = keypoints[idx];
                    if (kp.score > this.CONFIDENCE_THRESHOLD) {
                        this.ctx.beginPath();
                        this.ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                });
            }
            
            detectPushUp(keypoints) {
                const LEFT_SHOULDER = 5, RIGHT_SHOULDER = 6;
                const LEFT_ELBOW = 7, RIGHT_ELBOW = 8;
                const LEFT_WRIST = 9, RIGHT_WRIST = 10;
                
                const requiredKeypoints = [
                    keypoints[LEFT_SHOULDER], keypoints[LEFT_ELBOW], keypoints[LEFT_WRIST],
                    keypoints[RIGHT_SHOULDER], keypoints[RIGHT_ELBOW], keypoints[RIGHT_WRIST]
                ];
                
                if (!requiredKeypoints.every(kp => kp && kp.score > this.CONFIDENCE_THRESHOLD)) {
                    return;
                }
                
                const leftAngle = this.calculateAngle(
                    keypoints[LEFT_SHOULDER], keypoints[LEFT_ELBOW], keypoints[LEFT_WRIST]
                );
                const rightAngle = this.calculateAngle(
                    keypoints[RIGHT_SHOULDER], keypoints[RIGHT_ELBOW], keypoints[RIGHT_WRIST]
                );
                
                const angle = (leftAngle + rightAngle) / 2;
                const smoothedAngle = this.smoothValue(this.angleBuffer, angle, this.bufferSize);
                
                const avgShoulderY = (keypoints[LEFT_SHOULDER].y + keypoints[RIGHT_SHOULDER].y) / 2;
                this.smoothValue(this.movementBuffer, avgShoulderY, 10);
                
                const movementRange = this.movementBuffer.length >= 5 ? 
                    Math.max(...this.movementBuffer) - Math.min(...this.movementBuffer) : 0;
                
                const angleProgress = Math.max(0, Math.min(100, ((smoothedAngle - 60) / (180 - 60)) * 100));
                document.querySelector('.angle-fill').style.width = `${angleProgress}%`;
                
                const threshold = this.thresholds.pushup;
                
                if (movementRange > threshold.minMovement) {
                    if (this.stage === 'up' && smoothedAngle < (threshold.angleDown - 5)) {
                        this.stage = 'down';
                        this.repStartTime = Date.now();
                        document.querySelector('.stage').textContent = 'Going Down...';
                        document.querySelector('.stage').className = 'stage down';
                        this.playSound(440, 0.1);
                    } else if (this.stage === 'down' && smoothedAngle > (threshold.angleUp + 5)) {
                        this.stage = 'up';
                        this.exerciseCount++;
                        this.lastRepTime = (Date.now() - this.repStartTime) / 1000;
                        
                        const countEl = document.querySelector('.count');
                        countEl.textContent = this.exerciseCount;
                        countEl.classList.add('pulse');
                        setTimeout(() => countEl.classList.remove('pulse'), 300);
                        
                        document.querySelector('.stage').textContent = 'Great Rep!';
                        document.querySelector('.stage').className = 'stage up';
                        document.getElementById('repTime').textContent = `${this.lastRepTime.toFixed(1)}s`;
                        
                        this.playSound(880, 0.2);
                        this.speak(this.exerciseCount.toString(), true);
                        
                        if ('vibrate' in navigator) {
                            navigator.vibrate([50, 30, 50]);
                        }
                        
                        this.movementBuffer = [];
                    }
                }
                
                this.analyzeFormPushUp(keypoints);
            }
            
            detectSitUp(keypoints) {
                const LEFT_SHOULDER = 5, RIGHT_SHOULDER = 6;
                const LEFT_HIP = 11, RIGHT_HIP = 12;
                const LEFT_KNEE = 13, RIGHT_KNEE = 14;
                
                const requiredKeypoints = [
                    keypoints[LEFT_SHOULDER], keypoints[RIGHT_SHOULDER],
                    keypoints[LEFT_HIP], keypoints[RIGHT_HIP]
                ];
                
                if (!requiredKeypoints.every(kp => kp && kp.score > this.CONFIDENCE_THRESHOLD)) {
                    return;
                }
                
                // Calculate torso angle relative to ground
                const avgShoulderX = (keypoints[LEFT_SHOULDER].x + keypoints[RIGHT_SHOULDER].x) / 2;
                const avgShoulderY = (keypoints[LEFT_SHOULDER].y + keypoints[RIGHT_SHOULDER].y) / 2;
                const avgHipX = (keypoints[LEFT_HIP].x + keypoints[RIGHT_HIP].x) / 2;
                const avgHipY = (keypoints[LEFT_HIP].y + keypoints[RIGHT_HIP].y) / 2;
                
                // Calculate angle of torso relative to horizontal
                const torsoAngle = Math.abs(Math.atan2(avgShoulderY - avgHipY, avgShoulderX - avgHipX) * 180 / Math.PI);
                const smoothedAngle = this.smoothValue(this.angleBuffer, torsoAngle, this.bufferSize);
                
                // Track shoulder vertical movement
                this.smoothValue(this.movementBuffer, avgShoulderY, 10);
                
                const movementRange = this.movementBuffer.length >= 5 ? 
                    Math.max(...this.movementBuffer) - Math.min(...this.movementBuffer) : 0;
                
                // Update angle visualization (0-90 degrees for sit-ups)
                const angleProgress = Math.max(0, Math.min(100, (smoothedAngle / 90) * 100));
                document.querySelector('.angle-fill').style.width = `${angleProgress}%`;
                
                const threshold = this.thresholds.situp;
                
                if (movementRange > threshold.minMovement) {
                    if (this.stage === 'down' && smoothedAngle > (threshold.angleUp - 5)) {
                        this.stage = 'up';
                        this.exerciseCount++;
                        this.lastRepTime = (Date.now() - this.repStartTime) / 1000;
                        
                        const countEl = document.querySelector('.count');
                        countEl.textContent = this.exerciseCount;
                        countEl.classList.add('pulse');
                        setTimeout(() => countEl.classList.remove('pulse'), 300);
                        
                        document.querySelector('.stage').textContent = 'Great Rep!';
                        document.querySelector('.stage').className = 'stage up';
                        document.getElementById('repTime').textContent = `${this.lastRepTime.toFixed(1)}s`;
                        
                        this.playSound(880, 0.2);
                        this.speak(this.exerciseCount.toString(), true);
                        
                        if ('vibrate' in navigator) {
                            navigator.vibrate([50, 30, 50]);
                        }
                    } else if (this.stage === 'up' && smoothedAngle < (threshold.angleDown + 5)) {
                        this.stage = 'down';
                        this.repStartTime = Date.now();
                        document.querySelector('.stage').textContent = 'Going Down...';
                        document.querySelector('.stage').className = 'stage down';
                        this.playSound(440, 0.1);
                        
                        this.movementBuffer = [];
                    }
                }
                
                this.analyzeFormSitUp(keypoints);
            }
            
            detectSquat(keypoints) {
                const LEFT_HIP = 11, RIGHT_HIP = 12;
                const LEFT_KNEE = 13, RIGHT_KNEE = 14;
                const LEFT_ANKLE = 15, RIGHT_ANKLE = 16;
                
                const requiredKeypoints = [
                    keypoints[LEFT_HIP], keypoints[LEFT_KNEE], keypoints[LEFT_ANKLE],
                    keypoints[RIGHT_HIP], keypoints[RIGHT_KNEE], keypoints[RIGHT_ANKLE]
                ];
                
                if (!requiredKeypoints.every(kp => kp && kp.score > this.CONFIDENCE_THRESHOLD)) {
                    return;
                }
                
                // Calculate knee angles
                const leftKneeAngle = this.calculateAngle(
                    keypoints[LEFT_HIP], keypoints[LEFT_KNEE], keypoints[LEFT_ANKLE]
                );
                const rightKneeAngle = this.calculateAngle(
                    keypoints[RIGHT_HIP], keypoints[RIGHT_KNEE], keypoints[RIGHT_ANKLE]
                );
                
                const kneeAngle = (leftKneeAngle + rightKneeAngle) / 2;
                const smoothedAngle = this.smoothValue(this.angleBuffer, kneeAngle, this.bufferSize);
                
                // Track hip vertical movement
                const avgHipY = (keypoints[LEFT_HIP].y + keypoints[RIGHT_HIP].y) / 2;
                this.smoothValue(this.movementBuffer, avgHipY, 10);
                
                const movementRange = this.movementBuffer.length >= 5 ? 
                    Math.max(...this.movementBuffer) - Math.min(...this.movementBuffer) : 0;
                
                // Update angle visualization
                const threshold = this.thresholds.squat; // Get squat specific thresholds
                let angleProgress = ((smoothedAngle - threshold.angleDown) / (threshold.angleUp - threshold.angleDown)) * 100;
                angleProgress = Math.max(0, Math.min(100, angleProgress)); // Clamp between 0 and 100
                document.querySelector('.angle-fill').style.width = `${angleProgress}%`;
                
                if (movementRange > threshold.minMovement) {
                    if (this.stage === 'up' && smoothedAngle < (threshold.angleDown + 5)) { // Note: logic uses angleDown + 5
                        this.stage = 'down';
                        this.repStartTime = Date.now();
                        document.querySelector('.stage').textContent = 'Going Down...';
                        document.querySelector('.stage').className = 'stage down';
                        this.playSound(440, 0.1);
                    } else if (this.stage === 'down' && smoothedAngle > (threshold.angleUp - 5)) { // Note: logic uses angleUp - 5
                        this.stage = 'up';
                        this.exerciseCount++;
                        this.lastRepTime = (Date.now() - this.repStartTime) / 1000;
                        
                        const countEl = document.querySelector('.count');
                        countEl.textContent = this.exerciseCount;
                        countEl.classList.add('pulse');
                        setTimeout(() => countEl.classList.remove('pulse'), 300);
                        
                        document.querySelector('.stage').textContent = 'Great Rep!';
                        document.querySelector('.stage').className = 'stage up';
                        document.getElementById('repTime').textContent = `${this.lastRepTime.toFixed(1)}s`;
                        
                        this.playSound(880, 0.2);
                        this.speak(this.exerciseCount.toString(), true);
                        
                        if ('vibrate' in navigator) {
                            navigator.vibrate([50, 30, 50]);
                        }
                        
                        this.movementBuffer = [];
                    }
                }
                
                this.analyzeFormSquat(keypoints);
            }

            detectJumpingJack(keypoints) {
                const LEFT_SHOULDER = 5, RIGHT_SHOULDER = 6;
                const LEFT_WRIST = 9, RIGHT_WRIST = 10;
                const LEFT_HIP = 11, RIGHT_HIP = 12;
                const LEFT_ANKLE = 15, RIGHT_ANKLE = 16;

                const requiredKeypoints = [
                    keypoints[LEFT_SHOULDER], keypoints[RIGHT_SHOULDER], keypoints[LEFT_WRIST], keypoints[RIGHT_WRIST],
                    keypoints[LEFT_HIP], keypoints[RIGHT_HIP], keypoints[LEFT_ANKLE], keypoints[RIGHT_ANKLE]
                ];

                if (!requiredKeypoints.every(kp => kp && kp.score > this.CONFIDENCE_THRESHOLD)) {
                    return;
                }

                const shoulderWidth = Math.abs(keypoints[LEFT_SHOULDER].x - keypoints[RIGHT_SHOULDER].x);
                const feetWidth = Math.abs(keypoints[LEFT_ANKLE].x - keypoints[RIGHT_ANKLE].x);
                const avgWristY = (keypoints[LEFT_WRIST].y + keypoints[RIGHT_WRIST].y) / 2;
                const avgShoulderY = (keypoints[LEFT_SHOULDER].y + keypoints[RIGHT_SHOULDER].y) / 2;
                const avgHipY = (keypoints[LEFT_HIP].y + keypoints[RIGHT_HIP].y) / 2;

                const threshold = this.thresholds.jumpingjack;

                const armsAreUp = avgWristY < avgShoulderY;
                const armsAreDown = avgWristY > avgHipY;
                const feetAreApart = feetWidth > shoulderWidth * threshold.feetApartRatio;
                const feetAreTogether = feetWidth < shoulderWidth * threshold.feetTogetherRatio;

                // Update UI visualization
                const stanceProgress = Math.min(100, (feetWidth / (shoulderWidth * 1.5)) * 100);
                document.querySelector('.angle-fill').style.width = `${stanceProgress}%`;

                if (this.stage === 'down' && feetAreApart && armsAreUp) {
                    this.stage = 'up';
                    this.repStartTime = Date.now();
                    document.querySelector('.stage').textContent = 'Up!';
                    document.querySelector('.stage').className = 'stage up';
                    this.playSound(880, 0.1);
                } else if (this.stage === 'up' && feetAreTogether && armsAreDown) {
                    this.stage = 'down';
                    this.exerciseCount++;
                    this.lastRepTime = (Date.now() - this.repStartTime) / 1000;

                    const countEl = document.querySelector('.count');
                    countEl.textContent = this.exerciseCount;
                    countEl.classList.add('pulse');
                    setTimeout(() => countEl.classList.remove('pulse'), 300);

                    document.querySelector('.stage').textContent = 'Great Rep!';
                    document.querySelector('.stage').className = 'stage down';
                    document.getElementById('repTime').textContent = `${this.lastRepTime.toFixed(1)}s`;

                    this.playSound(440, 0.2);
                    this.speak(this.exerciseCount.toString(), true);

                    if ('vibrate' in navigator) {
                        navigator.vibrate([50, 30, 50]);
                    }
                }
                
                this.analyzeFormJumpingJack(keypoints);
            }
            
            detectExercise(keypoints) {
                switch(this.exerciseMode) {
                    case 'pushup':
                        this.detectPushUp(keypoints);
                        break;
                    case 'situp':
                        this.detectSitUp(keypoints);
                        break;
                    case 'squat':
                        this.detectSquat(keypoints);
                        break;
                    case 'jumpingjack':
                        this.detectJumpingJack(keypoints);
                        break;
                }
            }
            
            async detectPose() {
                if (!this.detector || !this.video || this.video.readyState < 2) {
                    this.animationId = requestAnimationFrame(() => this.detectPose());
                    return;
                }
                
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastFrameTime;
                
                if (this.performanceMode && this.frameSkip < this.maxFrameSkip && deltaTime < (1000 / (this.fps + 5))) {
                    this.frameSkip++;
                } else {
                    this.frameSkip = 0;
                    
                    this.ctx.save();
                    this.ctx.scale(-1, 1);
                    this.ctx.translate(-this.canvas.width, 0);
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.restore();
                    
                    try {
                        const startDetection = performance.now();
                        const poses = await this.detector.estimatePoses(this.video, {
                            flipHorizontal: false
                        });
                        const detectionTime = performance.now() - startDetection;
                        
                        if (poses && poses.length > 0 && poses[0].keypoints) {
                            this.drawOptimized(poses[0].keypoints);
                            this.detectExercise(poses[0].keypoints);
                        } else {
                            document.querySelector('.stage').textContent = 'No person detected';
                        }
                        
                        if (this.performanceMode) {
                            const currentFps = deltaTime > 0 ? Math.round(1000 / deltaTime) : 0;
                            document.querySelector('.fps').textContent = `${currentFps} FPS`;
                            document.getElementById('latency').textContent = `${Math.round(detectionTime)}ms`;
                        }
                    } catch (error) {
                        console.error('Pose detection error:', error);
                    }
                }
                
                this.lastFrameTime = currentTime;
                this.animationId = requestAnimationFrame(() => this.detectPose());
            }
            
            reset() {
                this.exerciseCount = 0;
                this.stage = (this.exerciseMode === 'situp' || this.exerciseMode === 'jumpingjack') ? 'down' : 'up';
                this.angleBuffer = [];
                this.movementBuffer = [];
                this.formQuality = 100;
                this.formErrors = [];
                this.previousFormError = null;
                
                document.querySelector('.count').textContent = '0';
                document.querySelector('.stage').textContent = 'Ready to Start';
                document.querySelector('.stage').className = 'stage';
                document.getElementById('formQuality').textContent = '--';
                document.getElementById('repTime').textContent = '--';
                document.getElementById('formIndicator').style.display = 'none';
                document.querySelector('.angle-fill').style.width = '0%';
                
                this.playSound(660, 0.3);
                const exerciseName = this.exerciseMode.replace(/([A-Z])/g, ' $1').toLowerCase() + 's';
                this.speak(`Count reset. Ready for ${exerciseName}`, true);
            }
            
            async toggleCamera() {
                this.facingMode = this.facingMode === 'user' ? 'environment' : 'user';
                
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                
                try {
                    await this.setupCamera();
                } catch (e) {
                    // Error already handled in setupCamera
                }
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                const soundBtn = document.getElementById('soundBtn');
                soundBtn.textContent = `Sound: ${this.soundEnabled ? 'ON' : 'OFF'}`;
                soundBtn.classList.toggle('active', this.soundEnabled);

                if (!this.soundEnabled && 'speechSynthesis' in window && window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel(); 
                } else if (this.soundEnabled) {
                    this.speak("Sound on", false);
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().catch(e => console.warn("Could not resume audio context:", e));
                    }
                }
            }
            
            togglePerformanceMode() {
                this.performanceMode = !this.performanceMode;
                document.getElementById('performanceMode').style.display = 
                    this.performanceMode ? 'block' : 'none';
            }
            
            showError(message) {
                const loadingDiv = document.getElementById('loading');
                loadingDiv.innerHTML = `
                    <div class="error">
                        <h3>âš ï¸ Error</h3>
                        <p>${message}</p>
                        <button onclick="location.reload()" style="margin-top: 20px;">
                            Reload Page
                        </button>
                    </div>
                `;
                loadingDiv.style.display = 'block';
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
            
            cleanup() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                if (this.video && this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    this.audioContext.close().catch(e => console.warn("Error closing audio context:", e));
                }
                if ('speechSynthesis' in window && window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }
            }
        }
        
        // Initialize the app
        const exerciseCounter = new ExerciseCounter();
        window.addEventListener('load', () => {
            exerciseCounter.init();
        });
        window.addEventListener('beforeunload', () => exerciseCounter.cleanup());
    </script>
</body>
</html>